<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="keywords" content="Aoki,Atsushi,Smalltalk,Smalltalker,Program,Programmer,Object,Oriented,Programming">
<meta name="description" content="ソフトウェア工学IIのホームページ">
<meta name="author" content="AOKI Atsushi">
<link rev="made" href="index.html">
<link rel="index" href="index.html">
<style type="text/css">
<!--
body {
  background-color : #ffffff;
  margin : 20px;
  padding : 10px;
  font-family : serif;
  font-size : 10pt;
}
a {
  text-decoration : underline;
  color : #000000;
}
a:link {
  background-color : #ffddbb;
}
a:visited {
  background-color : #ccffcc;
}
a:hover {
  background-color : #dddddd;
}
a:active {
  background-color : #dddddd;
}
div.belt {
  background-color : #eeeeee;
  padding : 0px 4px;
}
div.belt-yellow {
  background-color : #ffffcc;
  padding : 0px 4px;
}
div.belt-blue {
  background-color : #ddeeff;
  padding : 0px 4px;
}
div.right-small {
  text-align : right;
  font-size : 8pt;
}
img.border {
  border-width : 1px;
  border-color : #000000;
  vertical-align : middle;
}
img.borderless {
  border-width : 0px;
  vertical-align : middle;
}
p.belt {
  background-color : #ffeedd;
  padding : 4px 8px;
}
p.belt-blue {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt-yellow {
  background-color : #ffffcc;
  padding : 4px 8px;
}
table {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
}
table.profile {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
  margin-top : 8px;
  margin-left : 8px;
  margin-right : 8px;
  margin-bottom : 8px;
}
table.belt {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  background-color : #ffeedd;
  padding : 0px 0px;
  width : 100%;
}
table.content {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
}
table.font-fixed {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
  font-family : monospace;
}
table.nest {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 0px 0px;
}
td {
  padding : 0px 0px;
  vertical-align : middle;
}
td.center {
  text-align : center;
}
td.center-half {
  text-align : center;
  width : 50%;
  font-size : 8pt;
}
td.center-small {
  text-align : center;
  font-size : 8pt;
  padding : 0px 4px;
}
td.center-small-nopadding {
  text-align : center;
  font-size : 8pt;
  padding : 0px 0px;
}
td.center-white {
  text-align : center;
  background-color : #ffffff;
}
td.center-small-white {
  text-align : center;
  font-size : 8pt;
  background-color : #ffffff;
}
td.center-border1 {
  text-align : center;
  vertical-align : middle;
  empty-cells : show;
  border-style : solid;
  border-width : 1px;
  border-color : #ffc080;
  width : 22px;
  height : 22px;
}
td.left-small {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
}
td.left-small-white {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
td.right-small {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
}
td.right-small-white {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
th {
  padding : 0px 0px;
  vertical-align : middle;
}
#menu {
  margin: 0px 0px 0px 0px;
  padding: 0px;
  height: 32px;
}
#menu ul {
  margin: 0px;
  padding: 0px;
  list-style: none;
  text-align: center;
  clear: both;
}
#menu li {
  margin: 0px 5px 0px 0px;
  padding: 0px;
  float: left;
}
#menu a {
  display: block;
  padding: 2px 4px;
  text-decoration: none;
  margin: 0px;
  font-weight: bold;
  background: #FFFFFF;
  color: #333333;
  border: 1px solid #666666;
}
#menu a:hover {
  display: block;
  padding: 2px 4px;
  border-bottom: 1px solid #000000;
  text-decoration: none;
  background: #FFCC66;
}
#menu .current {
  background-color: #F45F57;
  font-weight: bold;
  color: #FFFFFF;
  border: 1px solid #333333;
}
-->
</style>
<title>ソフトウェア工学II「樹状整列」プログラム</title>
</head>
<body>
<div id="menu">
<ul>
  <li><a href="../index.html">ホーム</a></li>
  <li><a href="../Requirement/index.html">要求仕様書</a></li>
  <li><a href="../DevelopmentPlan/index.html">開発計画書</a></li>
  <li><a href="../BasicDesign/index.html">基本設計書</a></li>
  <li><a href="../DetailDesign/index.html">詳細設計書</a></li>
  <li><a href="../TestSpecification/index.html">テスト仕様書</a></li>
  <li><a href="../TestResult/index.html">テスト結果</a></li>
  <li><a href="../DevelopmentResult/index.html">開発実績</a></li>
  <li><a href="../Program/index.html" class="current">プログラム</a></li>
  <li><a href="../Manual/index.html">マニュアル</a></li>
</ul>
</div>
<hr>
<h2>ソフトウェア工学II「樹状整列」プログラム</h2>
<ul>
  <li><a href="#Example">Example</a>（メインクラス）</li>
  <li><a href="#Branch">Branch</a>（枝）</li>
  <li><a href="#Const">Const</a>（定数群）</li>
  <li><a href="#FileChooser">FileChooser</a>（ファイル）</li>
  <li><a href="#Forest">Forest</a>（森）</li>
  <li><a href="#ForestController">ForestController</a>（コントロール）</li>
  <li><a href="#ForestModel">ForestModel</a>（モデル）</li>
  <li><a href="#ForestView">ForestView</a>（ビュー）</li>
  <li><a href="#Node">Node</a>（ノード）</li>
  <li><a href="#NodeComparator">NodeComparator</a>（ノードソート）</li>
</ul>
<ul>
  <li><a href="#Example_2">Example</a>（メインクラス）</li>
  <li><a href="#Model">Model</a>（モデル）</li>
  <li><a href="#View">View</a>（ビュー）</li>
  <li><a href="#Controller">Controller</a>（コントローラ）</li>
</ul>
<ul>
  <li><a href="#Example_3">Example</a>（メインクラス）</li>
  <li><a href="#ColorUtility">ColorUtility</a>（色ユーティリティ）</li>
  <li><a href="#FileUtility">FileUtility</a>（ファイルユーティリティ）</li>
  <li><a href="#ImageUtility">ImageUtility</a>（イメージユーティリティ）</li>
  <li><a href="#StringUtility">StringUtility</a>（文字列ユーティリティ）</li>
</ul>
<ul>
  <li><a href="#Forest_Program.mf">Forest_Program.mf</a>（マニフェストファイル）</li>
  <li><a href="#Makefile">Makefile</a>（メイクファイル）</li>
  <li><a href="#build.xml">build.xml</a>（ビルドファイル）</li>
</ul>
<div class="belt">
<h3><a name="Example" href="../TestSpecification/index.html#Example">Example（メインクラス）</a></h3>
</div>
<pre>package forest;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.io.IOException;
import java.io.File;
import javax.swing.JFrame;

/**
 * 例題プログラム。
 */
public class Example extends Object {
    /**
     * メインメソッド
     * @param arguments
     * @throws IOException
     */

	public static void main(String[] args) throws IOException {
        FileChooser fileChooser = new FileChooser();
        File aFile = null;
        fileChooser.setLocation(0,0);

        while(aFile == null){
            aFile = fileChooser.getFile();
            System.out.print("");
        }

        ForestModel aModel = new ForestModel(aFile);
        ForestController aController = new ForestController();
		ForestView aView = new ForestView(aModel, aController);

        JFrame aWindow = new JFrame("Forest");
        aWindow.getContentPane().add(aView);
        aWindow.setLayout(null);
        aWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		int titleBarHeight = aWindow.getInsets().top;
		aWindow.getContentPane().setBackground(new Color(255,255,255));
		Point aPoint = new Point(Const.WINDOW_WIDTH, Const.WINDOW_HEIGHT);
		aWindow.setMinimumSize(new Dimension(aPoint.x, aPoint.y + titleBarHeight));
		aWindow.setResizable(true);
		aWindow.setSize(aPoint.x, aPoint.y + titleBarHeight);
		aWindow.setLocation(0, 0);
		aWindow.setVisible(true);
		aWindow.toFront();

        aModel.animate();

		return;
	}
}</pre>
<div class="belt">
<h3><a name="Branch" href="../TestSpecification/index.html#Branch">Branch（枝）</a></h3>
</div>
<pre>package forest;



/**
 * Branchクラス
 */
public class Branch extends Object {

    private Node parent;
    private Node child;

    /**
     * コンストラクタ
     * @param parent
     * @param child
     */

    Branch(Node parent, Node child) {
    this.parent = parent;
    this.child = child;

    }

    /**
     * 親ノードを応答する
     */

    public Node getParent() {
    return this.parent;
    }

    /**
     * 子ノードを応答する
     */

    public Node getChild() {
    return this.child;
    }
}
</pre><div class="belt">
<h3><a name="Const" href="../TestSpecification/index.html#Const">Const（定数群）</a></h3>
</div>
<pre>package forest;

/**
 * プログラムで使用する定数群
 */

public class Const extends Object
{
    public static final int WINDOW_WIDTH = 800;

    public static final int WINDOW_HEIGHT = 800;
 
    public static final int VERTICAL_GAP = 2;

    public static final int HORIZONTAL_GAP = 25;
 
    public static final int FONT_SIZE = 12;

    public static final int RECT_LINE_THICK = 1;

    public static final int SLEEP_TIME = 100;

}</pre>

<div class="belt">
<h3><a name="FileChooser" href="../TestSpecification/index.html#FileChooser">FileChooser（ファイル）</a></h3>
</div>
<pre>package forest;

import java.io.File;
import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JPanel;


/**
 * FileChooserクラス
 */
public class FileChooser extends JFrame implements ActionListener {

    File aFile;

    /**
     * コンストラクタ
     */
    FileChooser() {
        this.aFile = null;
        JButton aButton = new JButton("ファイル選択");
        aButton.addActionListener(this);
        JPanel aPanel = new JPanel();
        aPanel.add(aButton);

        this.setSize(300,200);
        this.setTitle("ファイル名を選択");
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.getContentPane().add(aPanel, BorderLayout.PAGE_END);
        this.setVisible(true);
    }

    /**
     * ファイル選択時の処理
     */

    public void actionPerformed(ActionEvent aEvent) {
        JFileChooser filechooser = new JFileChooser();
        int selected = filechooser.showOpenDialog(this);

        if (selected == JFileChooser.APPROVE_OPTION) {
            this.aFile = filechooser.getSelectedFile();
            System.out.println("ファイルが選択されました = "+this.aFile.getName());
        }
        else if (selected == JFileChooser.CANCEL_OPTION) {
            System.out.println("キャンセルされました。");
        }
        else if (selected == JFileChooser.ERROR_OPTION) {
            System.out.println("エラー又は取り消しがありました。");
        }

    }

    /**
     * 読み込んだファイルのインスタンスを応答する
     */
    public File getFile() {

        return this.aFile;
    }
}
</pre>

<div class="belt">
<h3><a name="Forest" href="../TestSpecification/index.html#Forest">Forest（森）</a></h3>
</div>
<pre>package forest;

import java.awt.Point;
import java.io.IOException;
import java.io.File;
import java.util.HashMap;
import java.util.ArrayList;
import utility.StringUtility;



/**
 * Forestクラス
 */

 
public class Forest extends Object {

    private ForestModel model;
    public static ArrayList<Node> rootNodes;
    private HashMap<Integer,Node> nodes;
    public static ArrayList<Branch> branches;
    public static int underLine;

	/**
	 * コンストラクタ
	 */
	public Forest() {
        this.model = null;
        this.rootNodes = new ArrayList<Node>();
        this.nodes = new HashMap<Integer,Node>();
        this.branches = new ArrayList<Branch>();
        this.underLine = 0;
	}

    /**
     * 指定されたテキストファイルの読み込む。
     * @param aFile
     */


    public void readFile(File aFile) throws IOException {
        ArrayList<String> textList = (ArrayList<String>) StringUtility.readTextFromFile(aFile);
        System.out.println(textList.size());

        int type = 0;
        for (String text : textList) {
            text = text.replaceAll(" ", "");
            System.out.println("> " + text);
            if ( text.equals("nodes:") ) {type = 1;}
            if ( text.equals("branches:") ) {type = 2;}
            this.setTypeData(type, text);
        }


        return;
    }

    /**
     * テキストデータからnodeとbranchを取り出して束縛する
     * @param type
     * @param text
     */
    private void setTypeData(int type, String text) {
        if ( text.equals("nodes:") ) {return;}
        if ( text.equals("branches:") ) {return;}

        if (type == 1)
        {
            String[] tmp = text.split(",");
            int nodeNumber = Integer.parseInt(tmp[0]);
            String nodeName = tmp[1];
            Node aNode = new Node(nodeNumber, nodeName);
            this.nodes.put(nodeNumber, aNode);
        }
        else if (type == 2)
        {
            String[] tmp = text.split(",");
            Node parentNode = this.nodes.get( Integer.parseInt(tmp[0]) );
            Node childNode = this.nodes.get( Integer.parseInt(tmp[1]) );

            parentNode.setChildren(childNode);
            childNode.setParent(parentNode);
            this.nodes.put(Integer.parseInt(tmp[0]), parentNode);
            this.nodes.put(Integer.parseInt(tmp[1]), childNode);

            Branch aBranch = new Branch(parentNode, childNode);
            this.branches.add(aBranch);
        }
        return;
    }

    /**
     * モデルを設定する
     * @param aModel
     */
    public void setModel(ForestModel aModel) {
        this.model = aModel;
        return;
    }

    /**
     * ルートノードのインスタンスを設定する
     */
    public void setRoot() {
        for (Node node : this.nodes.values()) {
            if(node.getParent() == null){ rootNodes.add(node); }
        }
        return;
    }

    /**
     * ノードのインスタンスを応答する
     * @return
     */
    public HashMap<Integer,Node> getNodes() {
        return this.nodes;
    }

    /**
     * ルートのインスタンスを応答する
     * @return
     */
    public ArrayList<Node> getRoot() {
        return this.rootNodes;
    }

    /**
     * ブランチのインスタンスを応答する
     * @return
     */
    public ArrayList<Branch> getBranches() {
        return this.branches;
    }

    /**
     * 木を再帰的に探索し，　下限の位置を元に位置を設定する．
     * モデルの内部状態が変化したので，自分の依存物へのupdateメッセージを送信
     * @param root
     * @param aPoint
     */
    public void visit(Node root, Point aPoint) {
        if(root.getVisit() == false){ root.setLocation(aPoint); }
        try {
            Thread.sleep(Const.SLEEP_TIME);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.model.changed();

        int childY = aPoint.y;
        int count=0;
        for(Node childNode : root.getChildren()) {
            while(childY <= this.underLine) {childY += 18;}
            this.visit(childNode,new Point(aPoint.x+root.getWidth()+Const.HORIZONTAL_GAP, childY)); //子Nodeを探索
            childNode.setVisit(true);
            count++;
            if(root.getChildren().size() > count) {
                childY += Const.VERTICAL_GAP + root.getHeight();
            }
        }

        if(this.underLine < childY) {this.underLine = childY;}
        if(root.getVisit() == false){root.setLocation( aPoint.x, (childY+aPoint.y+root.getHeight()) / 2 - (root.getHeight()/2) );}
        if(root.getParent()==null && root.getChildren().size()==1){ root.setLocation( aPoint.x, root.getChildren().get(0).getLocation().y);}

        return;
    }
}
</pre>

<div class="belt">
<h3><a name="ForestController" href="../TestSpecification/index.html#ForestController">ForestController（コントロール）</a></h3>
</div>
<pre>package forest;

import java.awt.event.MouseEvent;
import java.awt.Point;
import mvc.Controller;



/**
 * ForestControllerクラス
 */
public class ForestController extends Controller {

	/**
	 * コンストラクタ
	 */
	public ForestController() {
		super();
	}

	/**
	 * マウスクリックした位置のノードを出力する
	 */


	public void mouseClicked(MouseEvent aEvent) {
  	Point aPoint = aEvent.getPoint();
		aPoint.translate(view.scrollAmount().x, view.scrollAmount().y);
		ForestModel aForestModel = (ForestModel)(this.model);
		aForestModel.mouseClicked(aPoint, aEvent);


		return;
	}
}
</pre>

<div class="belt">
<h3><a name="ForestModel" href="../TestSpecification/index.html#ForestModel">ForestModel(モデル）</a></h3>
</div>
<pre>package forest;

import java.awt.event.MouseEvent;
import java.awt.Point;
import java.io.IOException;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import mvc.Model;



/**
 * ForestModelクラス
 */
public class ForestModel extends Model {

    private Forest aForest;

    /**
     * コンストラクタ
     * @param aFile
     */
	public ForestModel(File aFile) {
		super();
        this.aForest = new Forest();
        this.aForest.setModel(this);
        try {
            this.aForest.readFile(aFile);
        }
        catch(IOException e) {
            e.printStackTrace();
        }
        aForest.setRoot();

        int y=0;
        HashMap<Integer,Node> nodes = this.getForest().getNodes();
        for (Node aNode : nodes.values()) {
            aNode.setLocation(0,y);
            y += aNode.getSize().height+Const.VERTICAL_GAP;
        }
	}

    /**
     * Forestを応答する
     * @return
     */

    public Forest getForest() {

        return this.aForest;
    }

    /**
     * マウスクリックした位置を座標として受け取り，　その位置にNodeがあれば出力
     * @param aPoint
     * @param aEvent
     */

	public void mouseClicked(Point aPoint, MouseEvent aEvent) {
        HashMap<Integer,Node> nodes = aForest.getNodes();
        for (Node node : nodes.values()) {
            if(node.getLocation().x <= aPoint.x && node.getLocation().x+node.getWidth() >= aPoint.x) {
                if(node.getLocation().y <= aPoint.y && node.getLocation().y+node.getHeight() >= aPoint.y) {
                    System.out.println(node.getName());
                }
            }
        }
		return;
	}

    /**
     * アニメーション実行
     */


    public void animate() {
        ArrayList<Node> roots = this.aForest.getRoot();
        for(Node node : roots) {
            aForest.visit(node, new Point(0, Forest.underLine));
        }

        return;
    }
}
</pre>

<div class="belt">
<h3><a name="ForestView" href="../TestSpecification/index.html#ForestView">ForestView(ビュー）</a></h3>
</div>
<pre>package forest;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import mvc.View;


/**
 * ForestViewクラス。
 */
public class ForestView extends View {

    /**
     * コンストラクタ
     * @param aModel
     * @param aController
     */
	public ForestView(ForestModel aModel, ForestController aController) {
		super(aModel, aController);
        this.model = aModel;
        this.setSize(1500,1500);
	}

    /**
     * 指定されたグラフィックにNodeとBranchを描画
     */


    public void paintComponent(Graphics aGraphics) {
        int width = this.getWidth();
		int height = this.getHeight();
		aGraphics.setColor(Color.white);
        aGraphics.fillRect(0, 0, width, height);

        BufferedImage picture = (BufferedImage)this.createImage(width, height);
        Graphics aGraphicsBuffer = picture.getGraphics();
        aGraphicsBuffer.setColor(Color.white);
        aGraphicsBuffer.fillRect(0, 0, width, height);
        aGraphicsBuffer.setColor(Color.black);

        ForestModel aForestModel = (ForestModel)(this.model);
        ArrayList<Branch> branches = aForestModel.getForest().getBranches();
        for(Branch aBranch : branches) {
            Point parentPoint = aBranch.getParent().getLocation();
            Point childPoint = aBranch.getChild().getLocation();
            Dimension parentDimension = aBranch.getParent().getSize();
            Dimension childDimension = aBranch.getChild().getSize();

            aGraphicsBuffer.drawLine(parentPoint.x + parentDimension.width,
                                    parentPoint.y + parentDimension.height/2,
                                    childPoint.x,
                                    childPoint.y + childDimension.height/2);
		}

        HashMap<Integer,Node> nodes = aForestModel.getForest().getNodes();
        for (Node aNode : nodes.values()) {
            Point aPoint = aNode.getLocation();
            Dimension aDimension = aNode.getSize();
            aGraphicsBuffer.setFont(aNode.getFont());
            aGraphicsBuffer.drawString(aNode.getName(), aPoint.x + Const.RECT_LINE_THICK, aPoint.y + aNode.getSize().height - Const.RECT_LINE_THICK * 2 - 1); //1pxがずれる理由がまったくわかりませんでした。
            aGraphicsBuffer.drawRect(aPoint.x, aPoint.y, aDimension.width, aDimension.height);
		}

        Point aPoint = this.scrollAmount();
        aGraphics.drawImage(picture, 0-aPoint.x, 0-aPoint.y, this);



		return;
	}
}

</pre>

<div class="belt">
<h3><a name="Node" href="../TestSpecification/index.html#Node">Node(ノード）</a></h3>
</div>
<pre>package forest;

import java.awt.Font;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.border.LineBorder;
import javax.swing.JLabel;



public class Node extends JLabel {

	private int nodeNum;
    private String nodeName;
    private Node parent;
    private ArrayList<Node> children;
    private boolean visit;

    /**
     * コンストラクタ
     * @param num
     * @param name
     */
    Node(int num, String name) {
        this.nodeNum = num;
        this.nodeName = name;
        this.parent = null;
        this.children = new ArrayList<Node>();
        this.visit = false;

		this.setFont(new Font("Arial", Font.PLAIN, 12));
        this.setText(this.nodeName);
		this.setBorder(new LineBorder(Color.black, 1));
        this.setSize(this.getPreferredSize());
    }

    /**
     * ノード番号を応答する
     * @return
     */


    public int getNodeNum() {

        return this.nodeNum;
    }

    /**
     * ノード名を応答する
     */

    public String getName() {

        return this.nodeName;
    }

    /**
     * 親ノードのインスタンスを応答する
     */

    public Node getParent() {

        return this.parent;
    }

    /**
     * 子ノードのインスタンスを応答する
     * @return
     */

    public ArrayList<Node> getChildren() {

        return this.children;
    }

    /**
     * 親ノードのインスタンスを設定する。
     * @param aNode
     */

    public void setParent(Node node) {
        this.parent = node;

        return;
    }

    /**
     * 子ノードのインスタンスを設定する。
     * @param aNode
     */

    public void setChildren(Node aNode) {
        this.children.add(aNode);
        Collections.sort(this.children, new NodeComparator());

        return;
    }

    /**
     * 探索状態を設定する。
     * @param flag
     */

    public void setVisit(boolean flag) {
        this.visit = flag;

        return;
    }

    /**
     * 探索済みか応答する。
     */

    public boolean getVisit() {

        return this.visit;
    }
}
</pre>

<div class="belt">
<h3><a name="NodeComparator" href="../TestSpecification/index.html#NodeComparator">NodeComparator(ノードソート）</a></h3>
</div>
<pre>package forest;

import java.util.Comparator;

/**
 * NodeComparatorクラス
 * Nodeを辞書順にソートするためのクラス
 */
public class NodeComparator implements Comparator<Node> {

  @Override
  public int compare(Node node1, Node node2) {
    return node1.getName().compareTo(node2.getName());
  }
}

</pre>

<div class="belt">
<h3><a name="Example_2" href="../TestSpecification/index.html#Example_2">Example(メインクラス）</a></h3>
</div>
<pre>package mvc;

import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Robot;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import javax.swing.JFrame;




/**
 * 例題プログラム。
 */
public class Example extends Object
{
	/**
	 * 画面をキャプチャして画像化し、ビューとコントローラの3つのペア
	 *（MVC-1, MVC-2, MVC-3のウィンドウたち）から1つのモデルを観測している状態を作り出す。
	 * その後、モデルの内容物を先ほどキャプチャした画像にして、
	 * 自分が変化したと騒いだ瞬間、MVC-1, MVC-2, MVC-3のすべてのウィンドウが更新される。
	 * そして、モデルの内容物をnull化して、自分が変化したと騒ぎ、すべてのウィンドウが空に更新される。
	 * この過程を何回か繰り返すことで、MVC: Model-View-Controller（Observerデザインパターン）が
	 * きちんと動いているかを確かめる例題プログラムである。
	 * @param arguments 引数の文字列の配列
	 * バグ（2010年7月25日）
	 * 良好（2010年7月25日）
	 * 修正（2015年10月16日）
	 */

	public static void main(String[] arguments)
	{
		// スクリーンのサイズを求め、スクリーン全体をキャプチャ（画像に）する。
		Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		Robot aRobot = null;
		try
		{
			aRobot = new Robot();
		}
		catch (Exception anException)
		{
			System.err.println(anException);
			throw new RuntimeException(anException.toString());
		}
		BufferedImage anImage = aRobot.createScreenCapture(new Rectangle(screenSize));

		// ウィンドウのサイズを決め、モデルを作る。
		Dimension aDimension = new Dimension(800, 600);
		Model aModel = new Model();

		// MVCの出現数から、最初のウィンドウの出現位置を計算する。
		Integer howMany = 3; // MVCの出現回数
		Point offsetPoint = new Point(80, 60); // ウィンドウを出現させる時のオフセット(ズレ：ずらし)
		Integer width = aDimension.width + (offsetPoint.x * (howMany - 1));
		Integer height = aDimension.height + (offsetPoint.y * (howMany - 1));
		Integer x = (screenSize.width / 2) - (width / 2);
		Integer y = (screenSize.height / 2) - (height / 2);
		Point displayPoint = new Point(x, y);

		// MVCを出現回数分だけ出現させる。
		for (Integer index = 0; index < howMany; index++)
		{
			// 上記のモデルのビューとコンピュローラのペアを作り、ウィンドウに乗せる。
			View aView = new View(aModel);
			JFrame aWindow = new JFrame("MVC-" + Integer.toString(index + 1));
			aWindow.getContentPane().add(aView);

			// 高さはタイトルバーの高さを考慮してウィンドウの大きさを決定する。
			aWindow.addNotify();
			Integer titleBarHeight = aWindow.getInsets().top;
			width = aDimension.width;
			height = aDimension.height + titleBarHeight;
			Dimension windowSize = new Dimension(width, height);
			aWindow.setSize(windowSize.width, windowSize.height);

			// ウィンドウに各種の設定を行って出現させる。
			aWindow.setMinimumSize(new Dimension(400, 300 + titleBarHeight));
			aWindow.setResizable(true);
			aWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			x = displayPoint.x + (index * offsetPoint.x);
			y = displayPoint.y + (index * offsetPoint.y);
			aWindow.setLocation(x, y);
			aWindow.setVisible(true);
			aWindow.toFront();
		}

		// モデルのピクチャを、奇数の時はnullに、偶数の時はスクリーン全体のキャプチャ画像にする。
		for (Integer index = 0; index < (howMany * 4 - 1); index++)
		{
			try
			{
				Thread.sleep(1000);
			}
			catch (InterruptedException anException)
			{
				System.err.println(anException);
				throw new RuntimeException(anException.toString());
			}
			if (index % 2 == 0)
			{
				aModel.picture(anImage);
			}
			else
			{
				aModel.picture(null);
			}
			aModel.changed();
		}


		return;
	}
}
</pre>


<div class="belt">
<h3><a name="Model" href="../TestSpecification/index.html#Model">Model（モデル）</a></h3>
</div>
<pre>package mvc;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;




/**
 * モデル。データ管理を専門に行う。
 */
public class Model extends Object
{
	/**
	 * 依存物（Observerデザインパターンの観測者）：Viewのインスタンスたちを束縛する。
	 * 良好（2010年7月25日）
	 */
	protected ArrayList<View> dependents;

	/**
	 * 内容物として画像を束縛する。
	 * 良好（2010年7月25日）
	 */
	private BufferedImage picture;

	/**
	 * インスタンスを生成して初期化して応答する。
	 * 良好（2010年7月25日）
	 */
	public Model()
	{
		super();
		this.initialize();
		return;
	}

	/**
	 * 指定されたビューを依存物に設定する。
	 * @param aView このモデルの依存物となるビュー
	 * 良好（2010年7月25日）
	 */

	public void addDependent(View aView)
	{
		dependents.add(aView);

		return;
	}

	/**
	 * モデルの内部状態が変化していたので、自分の依存物へupdateのメッセージを送信する。
	 * 良好（2010年7月25日）
	 * 修正（2016年1月9日）：キャストからジェネリクスへ変更
	 */

	public void changed()
	{
		Iterator<View> anIterator = dependents.iterator();
		while (anIterator.hasNext())
		{
			View aView = anIterator.next();
			aView.update();
		}

		return;
	}

	/**
	 * 初期化する。
	 * 良好（2010年7月25日）
	 */

	private void initialize()
	{
		dependents = new ArrayList<View>();
		picture = null;

		return;
	}

	/**
	 * 何もしない。
	 * 良好（2010年7月25日）
	 */

	public void perform()
	{
		return;
	}

	/**
	 * 画像（モデルの内容物）を応答する。
	 * @return このモデルのpictureフィールドに格納されている画像
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */

	public BufferedImage picture()
	{
		return picture;
	}

	/**
	 * 画像（モデルの内容物）を設定する。
	 * @param anImage このモデルのpictureフィールドに格納する画像
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */

	public void picture(BufferedImage anImage)
	{
		picture = anImage;

		return;
	}

	/**
	 * このインスタンスを文字列にして応答する。
	 * @return 自分自身を表す文字列
	 * 良好（2010年7月25日）
	 */

	public String toString()
	{
		StringBuffer aBuffer = new StringBuffer();
		Class<?> aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append("[picture=");
		aBuffer.append(picture);
		aBuffer.append("]");

		return aBuffer.toString();
	}
}
</pre>
<div class="belt">
<h3><a name="View" href="../TestSpecification/index.html#View">View（ビュー）</a></h3>
</div>
<pre>package mvc;

import java.awt.Point;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import javax.swing.JPanel;
import java.awt.Color;




/**
 * ビュー。表示まわりを専門に行う。
 */
@SuppressWarnings("serial")
public class View extends JPanel
{
	/**
	 * 情報を握っているModelのインスタンスを束縛する。
	 * 束縛されるModelのインスタンスはpicture()というメッセージに応答できなければならない。
	 * 良好（2010年7月25日）
	 */
	protected Model model;

	/**
	 * 制御を司るControllerのインスタンスを束縛する。
	 * 良好（2010年7月25日）
	 */
	protected Controller controller;

	/**
	 * スクロール量としてPointのインスタンスを束縛する。
	 * 良好（2010年7月25日）
	 */
	private Point offset;

	/**
	 * インスタンスを生成して応答する。
	 * 指定されたモデルの依存物となり、コントローラを作り、モデルとビューを設定し、スクロール量を(0, 0)に設定する。
	 * @param aModel このビューのモデル
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */
	public View(Model aModel)
	{
		super();
		model = aModel;
		model.addDependent(this);
		controller = new Controller();
		controller.setModel(model);
		controller.setView(this);
		offset = new Point(0, 0);

		return;
	}

	/**
	 * インスタンスを生成して応答する。
	 * 指定されたモデルの依存物となり、指定されたコントローラにモデルとビューを設定し、スクロール量を(0, 0)に設定する。
	 * @param aModel このビューのモデル
	 * @param aController このビューのコントローラ
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */
	public View(Model aModel, Controller aController)
	{
		super();
		model = aModel;
		model.addDependent(this);
		controller = aController;
		controller.setModel(model);
		controller.setView(this);
		offset = new Point(0, 0);


		return;
	}

	/**
	 * 指定されたグラフィクスに背景色（明灰色）でビュー全体を塗り、その後にモデルの内容物を描画する。
	 * それはスクロール量（offset）を考慮してモデル画像（picture）をペイン（パネル）内に描画することである。
	 * @param aGraphics グラフィックス・コンテキスト
	 * 良好（2010年7月25日）
	 */

	public void paintComponent(Graphics aGraphics)
	{
		int width = this.getWidth();
		int height = this.getHeight();
		aGraphics.setColor(Color.lightGray);
		aGraphics.fillRect(0, 0, width, height);
		if (model == null) { return; }
		BufferedImage picture = model.picture();
		if (picture == null) { return; }
		aGraphics.drawImage(picture, offset.x, offset.y, null);

		return;
	}

	/**
	 * スクロール量（offsetの逆向きの大きさ）を応答する。
	 * @return X軸とY軸のスクロール量を表す座標
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */

	public Point scrollAmount()
	{
		int x = 0 - offset.x;
		int y = 0 - offset.y;

		return (new Point(x, y));
	}

	/**
	 * スクロール量を指定された座標分だけ相対スクロールする。
	 * @param aPoint X軸とY軸のスクロール量を表す座標
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */

	public void scrollBy(Point aPoint)
	{
		int x = offset.x + aPoint.x;
		int y = offset.y + aPoint.y;
		this.scrollTo(new Point(x, y));

		return;
	}

	/**
	 * スクロール量を指定された座標に設定（絶対スクロール）する。
	 * @param aPoint X軸とY軸の絶対スクロール量を表す座標
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */

	public void scrollTo(Point aPoint)
	{
		offset = aPoint;

		return;
	}

	/**
	 * このインスタンスを文字列にして応答する。
	 * @return 自分自身を表す文字列
	 * 良好（2010年7月25日）
	 */

	public String toString()
	{
		StringBuffer aBuffer = new StringBuffer();
		Class<?> aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append("[model=");
		aBuffer.append(model);
		aBuffer.append(",offset=");
		aBuffer.append(offset);
		aBuffer.append("]");

		return aBuffer.toString();
	}

	/**
	 * ビューの全領域を再描画する。
	 * 良好（2010年7月25日）
	 */
	public void update()
	{
		this.repaint(0, 0, this.getWidth(), this.getHeight());

		return;
	}
}
</pre>
<div class="belt">
<h3><a name="Controller" href="../TestSpecification/index.html#Controller">Controller（コントローラ）</a></h3>
</div>
<pre>package mvc;

import java.awt.Component;
import java.awt.Cursor;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import javax.swing.event.MouseInputAdapter;



/**
 * コントローラ。制御まわりを専門に行う。
 */
public class Controller extends MouseInputAdapter implements MouseWheelListener
{
	/**
	 * 情報を握っているModelのインスタンスを束縛する。
	 * 良好（2010年7月25日）
	 */
	protected Model model;

	/**
	 * 表示を司るViewのインスタンスを束縛する。
	 * 良好（2010年7月25日）
	 */
	protected View view;

	/**
	 * 以前にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
	 * 良好（2010年7月25日）
	 */
	private Point previous;

	/**
	 * 現在にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
	 * 良好（2010年7月25日）
	 */
	private Point current;

	/**
	 * インスタンスを生成して応答する。
	 * すべてのインスタンス変数（model, view, previous, current）をnull化する。
	 * 良好（2010年7月25日）
	 */
	public Controller()
	{
		super();
		model = null;
		view = null;
		previous = null;
		current = null;
		return;
	}

	/**
	 * 指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * モデル座標系でのクリック位置を割り出して標準出力に出力する。
	 * @param aMouseEvent マウスイベント
	 * 良好（2010年7月25日）
	 */

	public void mouseClicked(MouseEvent aMouseEvent)
	{
		Point aPoint = aMouseEvent.getPoint();
		aPoint.translate(view.scrollAmount().x, view.scrollAmount().y);
		System.out.println(aPoint);


		return;
	}

	/**
	 * マウスカーサの形状を移動の形に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数currentに設定すると共に、以前のマウスカーサの位置からの差分を計算する。
	 * そして、その差分だけビューに対してスクロールを依頼し、その後にビューの再描画を依頼する。
	 * 最後にインスタンス変数previousをインスタンス変数currentに更新する。
	 * @param aMouseEvent マウスイベント
	 * 良好（2010年7月25日）
	 */

	public void mouseDragged(MouseEvent aMouseEvent)
	{
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		int x = current.x - previous.x;
		int y = current.y - previous.y;
		Point point = new Point(x, y);
		view.scrollBy(point);
		view.repaint();
		previous = current;


		return;
	}

	/**
	 * 何もしない。
	 * @param aMouseEvent マウスイベント
	 * 良好（2010年7月25日）
	 */

	public void mouseEntered(MouseEvent aMouseEvent)
	{
		return;
	}

	/**
	 * 何もしない。
	 * @param aMouseEvent マウスイベント
	 * 良好（2010年7月25日）
	 */

	public void mouseExited(MouseEvent aMouseEvent)
	{
		return;
	}

	/**
	 * 何もしない。
	 * @param aMouseEvent マウスイベント
	 * 良好（2010年7月25日）
	 */

	public void mouseMoved(MouseEvent aMouseEvent)
	{
		return;
	}

	/**
	 * マウスカーサの形状を十字に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数currentに設定する共にインスタンス変数previousをインスタンス変数currentに更新する。
	 * @param aMouseEvent マウスイベント
	 * 良好（2010年7月25日）
	 */

	public void mousePressed(MouseEvent aMouseEvent)
	{
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		previous = current;


		return;
	}

	/**
	 * マウスカーサの形状をデフォルトに戻し、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数currentに設定する共にインスタンス変数previousをインスタンス変数currentに更新する。
	 * @param aMouseEvent マウスイベント
	 * 良好（2010年7月25日）
	 */

	public void mouseReleased(MouseEvent aMouseEvent)
	{
		Cursor aCursor = Cursor.getDefaultCursor();
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		previous = current;


		return;
	}

	/**
	 * 何もしない。
	 * @param aMouseWheelEvent マウスホィールイベント
	 * 良好（2010年7月25日）
	 */

	public void mouseWheelMoved(MouseWheelEvent aMouseWheelEvent)
	{
		return;
	}

	/**
	 * 指定されたモデルをインスタンス変数modelに設定する。
	 * @param aModel このコントローラのモデル
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */

	public void setModel(Model aModel)
	{
		model = aModel;


		return;
	}

	/**
	 * 指定されたビューをインスタンス変数viewに設定し、
	 * ビューのマウスのリスナおよびモーションリスナそしてホイールリスナをこのコントローラにする。
	 * @param aView このコントローラのビュー
	 * 良好（2010年7月25日）
	 * 修正（2015年2月9日）
	 */

	public void setView(View aView)
	{
		view = aView;
		view.addMouseListener(this);
		view.addMouseMotionListener(this);
		view.addMouseWheelListener(this);


		return;
	}

	/**
	 * このインスタンスを文字列にして応答する。
	 * @return 自分自身を表す文字列
	 * 良好（2010年7月25日）
	 */

	public String toString()
	{
		StringBuffer aBuffer = new StringBuffer();
		Class<?> aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append("[model=");
		aBuffer.append(model);
		aBuffer.append(",view=");
		aBuffer.append(view);
		aBuffer.append("]");

		return aBuffer.toString();
	}
}
</pre>

<div class="belt">
<h3><a name="Example_3" href="../TestSpecification/index.html#Example_3">Example（メインクラス）</a></h3>
</div>
<pre>package utility;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.awt.Point;
import java.io.File;
import java.util.List;
import javax.swing.JFrame;

import mvc.Controller;
import mvc.Model;
import mvc.View;



/**
 * ユーティリティの例題プログラム。 オブザーバ・デザインパターン(MVC:
 * Model-View-Controller)を用いた典型的(模範的)なプログラム。
 */
public class Example extends Object {
	/**
	 * 画像をファイルに書き出す際の番号。
	 */
	private static int fileNo = 0;

	/**
	 * ウィンドウの表示位置。
	 */
	private static Point displayPoint = new Point(30, 50);

	/**
	 * ウィンドウをずらして表示してゆく際の支距。
	 */
	private static Point offsetPoint = new Point(25, 25);

	/**
	 * ユーティリティの例題プログラム群を実行する。
	 *
	 * @param arguments 引数の文字列の配列
	 */

	public static void main(String[] arguments) {
		String aString = null;
		StringBuffer aBuffer = null;

		// CSVファイルを読み込む。
		aString = "SampleTexts".concat(File.separator.concat("PrimeMinisters.csv"));
		aBuffer = new StringBuffer();
		aBuffer.append(FileUtility.currentDirectory());
		aBuffer.append(aString);
		aString = aBuffer.toString();
		List<List<String>> aCollection = StringUtility.readRowsFromFile(aString);

		// 読み込んだCSVを一行ずつ標準出力へ書き出す。
		for (List<String> aRow : aCollection) {
			for (Integer index = 0; index < aRow.size(); index++) {
				if (index > 0) {
					System.out.print(",");
				}
				aString = aRow.get(index);
				aString = StringUtility.csvString(aString);
				System.out.print(aString);
			}
			System.out.println();
		}

		// CSVファイルを書き込む。
		aString = "SampleTexts".concat(File.separator.concat("PrimeMinisters2.csv"));
		aBuffer = new StringBuffer();
		aBuffer.append(FileUtility.currentDirectory());
		aBuffer.append(aString);
		aString = aBuffer.toString();
		StringUtility.writeRows(aCollection, aString);

		// 画像ファイルを読み込んで、ウィンドウの中に表示する。
		aString = "SampleImages".concat(File.separator.concat("CROWN.jpg"));
		aBuffer = new StringBuffer();
		aBuffer.append(System.getProperty("user.dir"));
		aBuffer.append(File.separator);
		aBuffer.append(aString);
		aString = aBuffer.toString();
		BufferedImage theImage = ImageUtility.readImage(aString);
		Example.open(theImage, "CROWN (Color)");

		// 読み込んだ画像をグレースケール画像に変換して、ウィンドウの中に表示する。
		BufferedImage anImage = ImageUtility.grayscaleImage(theImage);
		Example.open(anImage, "CROWN (Gray Scale)");

		// 読み込んだ画像を縮小（0.75倍の大きさに変換）して、ウィンドウの中に表示する。
		double factor = 0.75d;
		int width = (int) ((double) (theImage.getWidth()) * factor);
		int height = (int) ((double) (theImage.getHeight()) * factor);
		anImage = ImageUtility.adjustImage(theImage, width, height);
		Example.open(anImage, "CROWN (Shrinked)");

		// 読み込んだ画像を拡大（1.25倍の大きさに変換）して、ウィンドウの中に表示する。
		factor = 1.25d;
		width = (int) ((double) (theImage.getWidth()) * factor);
		height = (int) ((double) (theImage.getHeight()) * factor);
		anImage = ImageUtility.adjustImage(theImage, width, height);
		Example.open(anImage, "CROWN (Magnified)");

		// URL文字列で指定された画像を読み込んで、ウィンドウの中に表示する。
		aString = "http://aokilab.kyoto-su.ac.jp/documents/BlackBook/images/BlackBookFrontPage335x432.jpg";
		anImage = ImageUtility.readImageFromURL(aString);
		Example.open(anImage, "Black Book");

		// PDFファイルに関連付けられたアプリケーションを起動してファイルを開く。
		aString = "SamplePDFs".concat(File.separator.concat("三つの世界.key.pdf"));
		aBuffer = new StringBuffer();
		aBuffer.append(FileUtility.currentDirectory());
		aBuffer.append(aString);
		aString = aBuffer.toString();
		FileUtility.open(aString);


		return;

	}

	/**
	 * 描画画像(anImage)とラベル文字列(labelString)を指定してMVCを作り、表示位置(displayPoint)にウィンドウを開く。
	 *
	 * @param anImage     描画画像
	 * @param labelString ラベル文字列
	 */

	private static void open(BufferedImage anImage, String labelString) {
		Model aModel = new Model();
		aModel.picture(anImage);
		View aView = new View(aModel, new Controller());

		JFrame aWindow = new JFrame(labelString);
		aWindow.getContentPane().add(aView);
		Dimension aDimension = new Dimension(anImage.getWidth(), anImage.getHeight());
		aWindow.setMinimumSize(aDimension);
		aWindow.setMaximumSize(aDimension);
		aWindow.setResizable(false);
		aWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		aWindow.addNotify();
		int titleBarHeight = aWindow.getInsets().top;
		aWindow.setSize(aDimension.width, aDimension.height + titleBarHeight);
		aWindow.setLocation(displayPoint.x, displayPoint.y);
		aWindow.setVisible(true);

		Example.write(anImage);
		displayPoint = new Point(displayPoint.x + offsetPoint.x, displayPoint.y + offsetPoint.y);


		return;

	}

	/**
	 * 描画画像(anImage)をResultImagesというディレクトリの中に連番を付けて書き込む。
	 *
	 * @param anImage 描画画像
	 */

	private static void write(BufferedImage anImage) {
		File aDirectory = new File("ResultImages");
		if (aDirectory.exists() == false) {
			try {
				aDirectory.mkdir();
			} catch (SecurityException anException) {
				anException.printStackTrace();
			}
		}
		String aString = Integer.toString(fileNo++);
		while (aString.length() < 2) {
			aString = "0".concat(aString);
		}
		ImageUtility.writeImage(anImage,
				aDirectory.getName().concat(File.separator.concat("Utility".concat(aString.concat(".jpg")))));

		return;


	}
}

</pre>

<div class="belt">
<h3><a name="ColorUtility" href="../TestSpecification/index.html#ColorUtility">ColorUtility（色ユーティリティ）</a></h3>
</div>
<pre>package utility;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.awt.Point;
import java.io.File;
import java.util.List;
import javax.swing.JFrame;

import mvc.Controller;
import mvc.Model;
import mvc.View;



/**
 * ユーティリティの例題プログラム。 オブザーバ・デザインパターン(MVC:
 * Model-View-Controller)を用いた典型的(模範的)なプログラム。
 */
public class Example extends Object {
	/**
	 * 画像をファイルに書き出す際の番号。
	 */
	private static int fileNo = 0;

	/**
	 * ウィンドウの表示位置。
	 */
	private static Point displayPoint = new Point(30, 50);

	/**
	 * ウィンドウをずらして表示してゆく際の支距。
	 */
	private static Point offsetPoint = new Point(25, 25);

	/**
	 * ユーティリティの例題プログラム群を実行する。
	 *
	 * @param arguments 引数の文字列の配列
	 */

	public static void main(String[] arguments) {
		String aString = null;
		StringBuffer aBuffer = null;

		// CSVファイルを読み込む。
		aString = "SampleTexts".concat(File.separator.concat("PrimeMinisters.csv"));
		aBuffer = new StringBuffer();
		aBuffer.append(FileUtility.currentDirectory());
		aBuffer.append(aString);
		aString = aBuffer.toString();
		List<List<String>> aCollection = StringUtility.readRowsFromFile(aString);

		// 読み込んだCSVを一行ずつ標準出力へ書き出す。
		for (List<String> aRow : aCollection) {
			for (Integer index = 0; index < aRow.size(); index++) {
				if (index > 0) {
					System.out.print(",");
				}
				aString = aRow.get(index);
				aString = StringUtility.csvString(aString);
				System.out.print(aString);
			}
			System.out.println();
		}

		// CSVファイルを書き込む。
		aString = "SampleTexts".concat(File.separator.concat("PrimeMinisters2.csv"));
		aBuffer = new StringBuffer();
		aBuffer.append(FileUtility.currentDirectory());
		aBuffer.append(aString);
		aString = aBuffer.toString();
		StringUtility.writeRows(aCollection, aString);

		// 画像ファイルを読み込んで、ウィンドウの中に表示する。
		aString = "SampleImages".concat(File.separator.concat("CROWN.jpg"));
		aBuffer = new StringBuffer();
		aBuffer.append(System.getProperty("user.dir"));
		aBuffer.append(File.separator);
		aBuffer.append(aString);
		aString = aBuffer.toString();
		BufferedImage theImage = ImageUtility.readImage(aString);
		Example.open(theImage, "CROWN (Color)");

		// 読み込んだ画像をグレースケール画像に変換して、ウィンドウの中に表示する。
		BufferedImage anImage = ImageUtility.grayscaleImage(theImage);
		Example.open(anImage, "CROWN (Gray Scale)");

		// 読み込んだ画像を縮小（0.75倍の大きさに変換）して、ウィンドウの中に表示する。
		double factor = 0.75d;
		int width = (int) ((double) (theImage.getWidth()) * factor);
		int height = (int) ((double) (theImage.getHeight()) * factor);
		anImage = ImageUtility.adjustImage(theImage, width, height);
		Example.open(anImage, "CROWN (Shrinked)");

		// 読み込んだ画像を拡大（1.25倍の大きさに変換）して、ウィンドウの中に表示する。
		factor = 1.25d;
		width = (int) ((double) (theImage.getWidth()) * factor);
		height = (int) ((double) (theImage.getHeight()) * factor);
		anImage = ImageUtility.adjustImage(theImage, width, height);
		Example.open(anImage, "CROWN (Magnified)");

		// URL文字列で指定された画像を読み込んで、ウィンドウの中に表示する。
		aString = "http://aokilab.kyoto-su.ac.jp/documents/BlackBook/images/BlackBookFrontPage335x432.jpg";
		anImage = ImageUtility.readImageFromURL(aString);
		Example.open(anImage, "Black Book");

		// PDFファイルに関連付けられたアプリケーションを起動してファイルを開く。
		aString = "SamplePDFs".concat(File.separator.concat("三つの世界.key.pdf"));
		aBuffer = new StringBuffer();
		aBuffer.append(FileUtility.currentDirectory());
		aBuffer.append(aString);
		aString = aBuffer.toString();
		FileUtility.open(aString);


		return;

	}

	/**
	 * 描画画像(anImage)とラベル文字列(labelString)を指定してMVCを作り、表示位置(displayPoint)にウィンドウを開く。
	 *
	 * @param anImage     描画画像
	 * @param labelString ラベル文字列
	 */

	private static void open(BufferedImage anImage, String labelString) {
		Model aModel = new Model();
		aModel.picture(anImage);
		View aView = new View(aModel, new Controller());

		JFrame aWindow = new JFrame(labelString);
		aWindow.getContentPane().add(aView);
		Dimension aDimension = new Dimension(anImage.getWidth(), anImage.getHeight());
		aWindow.setMinimumSize(aDimension);
		aWindow.setMaximumSize(aDimension);
		aWindow.setResizable(false);
		aWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		aWindow.addNotify();
		int titleBarHeight = aWindow.getInsets().top;
		aWindow.setSize(aDimension.width, aDimension.height + titleBarHeight);
		aWindow.setLocation(displayPoint.x, displayPoint.y);
		aWindow.setVisible(true);

		Example.write(anImage);
		displayPoint = new Point(displayPoint.x + offsetPoint.x, displayPoint.y + offsetPoint.y);


		return;

	}

	/**
	 * 描画画像(anImage)をResultImagesというディレクトリの中に連番を付けて書き込む。
	 *
	 * @param anImage 描画画像
	 */

	private static void write(BufferedImage anImage) {
		File aDirectory = new File("ResultImages");
		if (aDirectory.exists() == false) {
			try {
				aDirectory.mkdir();
			} catch (SecurityException anException) {
				anException.printStackTrace();
			}
		}
		String aString = Integer.toString(fileNo++);
		while (aString.length() < 2) {
			aString = "0".concat(aString);
		}
		ImageUtility.writeImage(anImage,
				aDirectory.getName().concat(File.separator.concat("Utility".concat(aString.concat(".jpg")))));

		return;


	}
}

</pre>

<div class="belt">
<h3><a name="FileUtility" href="../TestSpecification/index.html#FileUtility">FileUtility（ファイルユーティリティ）</a></h3>
</div>
<pre>package utility;

import java.awt.Desktop;
import java.io.File;
import java.io.IOException;


/**
 * ファイルのユーティリティ。
 */
public class FileUtility extends Object
{
	/**
	 * カレントディレクトリを文字列（最後が必ずパス区切り文字となる）として応答する。
	 * @return カレントディレクトリの文字列
	 */

	public static String currentDirectory()
	{
		String aString = System.getProperty("user.dir");
		if (aString == null)
		{
			aString = new File(".").getAbsoluteFile().getParent();
		}
		if (aString == null)
		{
			aString = ".";
		}
		StringBuffer aBuffer = new StringBuffer();
		aBuffer.append(aString);
		if (aString.charAt(aString.length() - 1) != File.separatorChar)
		{
			aBuffer.append(File.separator);
		}
		aString = aBuffer.toString();


		return aString;

	}
	/**
	 * 開こうとするファイルを受け取り、そのファイルに関連付けられたアプリケーションを起動してファイルを開く。
	 * @param aFile 開こうとするファイル
	 */

	public static void open(File aFile)
	{
		Desktop aDesktop = Desktop.getDesktop();
		try { aDesktop.open(aFile); }
		catch (IOException anException) { anException.printStackTrace(); }


		return;

	}

	/**
	 * 開こうとするファイル名を文字列として受け取り、そのファイルに関連付けられたアプリケーションを起動してファイルを開く。
	 * @param aString 開こうとするファイル名の文字列
	 */

	public static void open(String aString)
	{
		File aFile = new File(aString);
		FileUtility.open(aFile);

		return;

	}
}

</pre>

<div class="belt">
<h3><a name="ImageUtility" href="../TestSpecification/index.html#ImageUtility">ImageUtility（イメージユーティリティ）</a></h3>
</div>
<pre>package utility;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.RenderingHints;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import javax.imageio.ImageIO;



/**
 * 画像のユーティリティ。
 */
public class ImageUtility extends Object
{
	/**
	 * 画像(anImage)を指定された幅(width)と高さ(height)に変形した複製を応答する。
	 * @param anImage 画像
	 * @param width 幅(横)
	 * @param height 高さ(縦)
	 * @return 画像
	 */

	public static BufferedImage adjustImage(BufferedImage anImage, int width, int height)
	{
		BufferedImage adjustedImage = new BufferedImage(width, height, anImage.getType());
		Graphics2D aGraphics = adjustedImage.createGraphics();
		aGraphics.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
		aGraphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		aGraphics.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
		aGraphics.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
		aGraphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		aGraphics.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
		aGraphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
		aGraphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
		aGraphics.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);
		aGraphics.drawImage(anImage, 0, 0, width, height, null);


		return adjustedImage;

	}

	/**
	 * 画像(anImage)をグレースケール画像に変換した複製を応答する。
	 * @param anImage 画像(カラー)
	 * @return 画像(グレースケール)
	 */

	public static BufferedImage grayscaleImage(BufferedImage anImage)
	{
		int width = anImage.getWidth();
		int height = anImage.getHeight();
		BufferedImage grayscaleImage = new BufferedImage(anImage.getWidth(), anImage.getHeight(), anImage.getType());
		for (int y = 0; y < height; y++)
		{
			for (int x = 0; x < width; x++)
			{
				int aRGB = anImage.getRGB(x, y);
				double luminance = ColorUtility.luminanceFromRGB(aRGB);
				aRGB = ColorUtility.convertRGBtoINT(luminance, luminance, luminance);
				grayscaleImage.setRGB(x, y, aRGB);
			}
		}

		return grayscaleImage;


	}

	/**
	 * 画像(anImage)をコピーして応答する。
	 * @param anImage 画像
	 * @return コピー画像
	 */

	public static BufferedImage copyImage(BufferedImage anImage)
	{
		BufferedImage copiedImage = new BufferedImage(anImage.getWidth(), anImage.getHeight(), anImage.getType());
		Graphics aGraphics = copiedImage.createGraphics();
		aGraphics.setColor(Color.white);
		aGraphics.fillRect(0, 0, copiedImage.getWidth(), copiedImage.getHeight());
		aGraphics.drawImage((Image)anImage, 0, 0, null);

		return copiedImage;

	}

	/**
	 * 画像を輝度マトリックスへ変換して応答する。
	 * @param anImage 画像
	 * @return 輝度（ルミナンス）の二次元配列
	 */

	public static double[][] convertImageToLuminanceMatrix(BufferedImage anImage)
	{
		int width = anImage.getWidth();
		int height = anImage.getHeight();
		double[][] aMatrix = new double[height][width];
		for (int y = 0; y < height; y++)
		{
			for (int x = 0; x < width; x++)
			{
				int aRGB = anImage.getRGB(x, y);
				aMatrix[y][x] = ColorUtility.luminanceFromRGB(aRGB);
			}
		}


		return aMatrix;


	}

	/**
	 * 画像をYUVマトリックスへ変換して応答する。
	 * @param anImage 画像
	 * @return yの二次元配列とuの二次元配列とvの二次元配列の配列
	 */

	public static double[][][] convertImageToYUVMatrixes(BufferedImage anImage)
	{
		int width = anImage.getWidth();
		int height = anImage.getHeight();
		double[][] yMatrix = new double[height][width];
		double[][] uMatrix = new double[height][width];
		double[][] vMatrix = new double[height][width];
		for (int y = 0; y < height; y++)
		{
			for (int x = 0; x < width; x++)
			{
				int aRGB = anImage.getRGB(x, y);
				double[] yuv = ColorUtility.convertRGBtoYUV(aRGB);
				yMatrix[y][x] = yuv[0];
				uMatrix[y][x] = yuv[1];
				vMatrix[y][x] = yuv[2];
			}
		}

		return new double[][][] { yMatrix, uMatrix, vMatrix };

	}

	/**
	 * 輝度マトリックスを画像へ変換して応答する。
	 * @param aMatrix 輝度（ルミナンス）の二次元配列
	 * @return 画像
	 */

	public static BufferedImage convertLuminanceMatrixToImage(double[][] aMatrix)
	{
		int width = aMatrix[0].length;
		int height = aMatrix.length;
		BufferedImage anImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		Graphics2D aGraphics = anImage.createGraphics();
		aGraphics.setColor(Color.white);
		aGraphics.fillRect(0, 0, width, height);
		for (int y = 0; y < height; y++)
		{
			for (int x = 0; x < width; x++)
			{
				double luminance = aMatrix[y][x];
				// Color aColor = ColorUtility.colorFromLuminance(luminance);
				// aGraphics.setColor(aColor);
				// aGraphics.fillRect(x, y, 1, 1);
				double[] rgb = ColorUtility.convertYUVtoRGB(luminance, 0.0d, 0.0d);
				int aRGB = ColorUtility.convertRGBtoINT(rgb);
				anImage.setRGB(x, y, aRGB);
			}
		}

		return anImage;

	}

	/**
	 * YUVマトリックスを画像へ変換して応答する。
	 * @param yuvMatrixes yの二次元配列とuの二次元配列とvの二次元配列の配列
	 * @return 画像
	 */

	public static BufferedImage convertYUVMatrixesToImage(double[][][] yuvMatrixes)
	{
		double[][] yMatrix = yuvMatrixes[0];
		double[][] uMatrix = yuvMatrixes[1];
		double[][] vMatrix = yuvMatrixes[2];
		int width = yMatrix[0].length;
		int height = yMatrix.length;
		BufferedImage anImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		Graphics2D aGraphics = anImage.createGraphics();
		aGraphics.setColor(Color.white);
		aGraphics.fillRect(0, 0, width, height);
		for (int y = 0; y < height; y++)
		{
			for (int x = 0; x < width; x++)
			{
				// double[] yuv = new double[] { yMatrix[y][x], uMatrix[y][x], vMatrix[y][x] };
				// Color aColor = ColorUtility.colorFromYUV(yuv);
				// aGraphics.setColor(aColor);
				// aGraphics.fillRect(x, y, 1, 1);
				double[] rgb = ColorUtility.convertYUVtoRGB(yMatrix[y][x], uMatrix[y][x], vMatrix[y][x]);
				int aRGB = ColorUtility.convertRGBtoINT(rgb);
				anImage.setRGB(x, y, aRGB);
			}
		}

		return anImage;

	}

	/**
	 * ファイル(aFile)から画像を読み込んで応答する。
	 * @param aFile ファイル（ファイルの拡張子のフォーマットが重要）
	 * @return 画像
	 */

	public static BufferedImage readImage(File aFile)
	{
		return ImageUtility.readImageFromFile(aFile);

	}

	/**
	 * ファイル名(aString)で指定されるファイルから画像を読み込んで応答する。
	 * @param aString ファイル名（ファイル名の拡張子のフォーマットが重要）
	 * @return 画像
	 */

	public static BufferedImage readImage(String aString)
	{
		return ImageUtility.readImageFromFile(aString);

	}

	/**
	 * ファイル(aFile)から画像を読み込んで応答する。
	 * @param aFile ファイル（ファイルの拡張子のフォーマットが重要）
	 * @return 画像
	 */

	public static BufferedImage readImageFromFile(File aFile)
	{
		BufferedImage anImage = null;
		try { anImage = ImageIO.read(aFile); }
		catch (IOException anException) { anException.printStackTrace(); }
		return anImage;

	}

	/**
	 * ファイル名(aString)で指定されるファイルから画像を読み込んで応答する。
	 * @param aString ファイル名（ファイル名の拡張子のフォーマットが重要）
	 * @return 画像
	 */

	public static BufferedImage readImageFromFile(String aString)
	{
		File aFile = new File(aString);
		return ImageUtility.readImageFromFile(aFile);

	}

	/**
	 * URL(aURL)から画像を読み込んで応答する。
	 * @param aURL ユニフォームリソースロケータ（最後の拡張子のフォーマットが重要）
	 * @return 画像
	 */

	public static BufferedImage readImageFromURL(URL aURL)
	{
		BufferedImage anImage = null;
		try { anImage = ImageIO.read(aURL); }
		catch (IOException anException) { anException.printStackTrace(); }
		return anImage;

	}

	/**
	 * URL(aString)で指定されるファイルから画像を読み込んで応答する。
	 * @param aString ファイル名（ファイル名の拡張子のフォーマットが重要）
	 * @return 画像
	 */

	public static BufferedImage readImageFromURL(String aString)
	{
		URL aURL = null;
		try { aURL = new URL(aString); }
		catch (MalformedURLException anException) { anException.printStackTrace(); }

		return ImageUtility.readImageFromURL(aURL);

	}

	/**
	 * 画像をファイル(aFile)へ拡張子で指定されたフォーマットで書き込む。
	 * @param anImage 画像
	 * @param aFile ファイル（ファイルの拡張子のフォーマットが重要）
	 */

	public static void writeImage(BufferedImage anImage, File aFile)
	{
		String aString = aFile.getName();
		aString = aString.substring(aString.lastIndexOf(".") + 1);
		try { ImageIO.write(anImage, aString, aFile); }
		catch (IOException anException) { anException.printStackTrace(); }
		return;

	}

	/**
	 * 画像をファイル名(aString)で指定されるファイルへ拡張子で指定されたフォーマットで書き込む。
	 * @param anImage 画像
	 * @param aString ファイル名（ファイル名の拡張子のフォーマットが重要）
	 */

	public static void writeImage(BufferedImage anImage, String aString)
	{
		File aFile = new File(aString);
		ImageUtility.writeImage(anImage, aFile);

		return;

	}
}

</pre>

<div class="belt">
<h3><a name="StringUtility" href="../TestSpecification/index.html#StringUtility">StringUtility（文字列ユーティリティ）</a></h3>
</div>
<pre>package utility;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;




/**
 * 文字列のユーティリティ。
 */
public class StringUtility extends Object
{
	/**
	 * 文字列(aString)をCSV文字列にして応答するクラスメソッド。
	 * スペースやカンマなどの特殊文字が含まれる場合にはダブルクォートで囲まれる。
	 * @param aString 文字列
	 * @return CSV文字列
	 */
	public static String csvString(String aString)
	{
		StringBuffer aBuffer = new StringBuffer();
		aBuffer.append('"');
		aBuffer.append(',');
		aBuffer.append(' ');
		aBuffer.append('\t');
		aBuffer.append('\r');
		aBuffer.append('\n');
		aBuffer.append('\f');
		String specialCharacters = aBuffer.toString();

		boolean needDoubleQuote = false;
		for (int index = 0; index < aString.length(); index++)
		{
			Character aCharacter = aString.charAt(index);
			if (specialCharacters.indexOf(aCharacter) != -1) { needDoubleQuote = true; }
		}
		String theString = aString;
		if (needDoubleQuote)
		{
			aBuffer = new StringBuffer();
			aBuffer.append('"');
			for (int index = 0; index < aString.length(); index++)
			{
				Character aCharacter = aString.charAt(index);
				aBuffer.append(aCharacter);
				if (aCharacter == '"') { aBuffer.append('"'); }
			}
			aBuffer.append('"');
			theString = aBuffer.toString();
		}

		return theString;
	}

	/**
	 * 入出力する際の文字コードを応答するクラスメソッド。
	 * @return 文字コード
	 */
	public static String encodingSymbol()
	{
		return "UTF-8";
	}

	/**
	 * バッファードリーダー(aBufferdReader)から一文字を読み込んで応答するクラスメソッド。
	 * @param aBufferdReader バッファードリーダー
	 * @return 一文字
	 */
	public static Character getChar(BufferedReader aBufferdReader)
	{
		try
		{
			int charValue = aBufferdReader.read();
			if (charValue == -1) { return null; }
			Character aCharacter = Character.valueOf((char)charValue);
			if (aCharacter == '\n') // LF
			{
				return Character.valueOf('\n');
			}
			else
			{
				if (aCharacter == '\r') // CR
				{
					aBufferdReader.mark(256);
					charValue = aBufferdReader.read();
					if (charValue == -1) // EOF
					{
						aBufferdReader.reset();
						return Character.valueOf('\n');
					}
					aCharacter = Character.valueOf((char)charValue);
					if (aCharacter == '\n') // CRLF
					{
						return aCharacter;
					}
					else
					{
						aBufferdReader.reset();
						return Character.valueOf('\n');
					}
				}
				else
				{
					return aCharacter;
				}
			}
		}
		catch (IOException anException) { anException.printStackTrace(); }

		return null;

	}

	/**
	 * バッファードリーダー(aBufferdReader)からCSVとして一行を読み込んで集まりにして応答するクラスメソッド。
	 * @param aBufferdReader バッファードリーダー
	 * @return 文字列の集まり：CSVの一行
	 */
	public static List<String> getRowCSV(BufferedReader aBufferdReader)
	{
		List<String> aCollection = new ArrayList<String>();
		StringBuffer aBuffer = new StringBuffer();
		boolean aBoolean = true;
		Character aCharacter = null;
		while (aBoolean)
		{
			aCharacter = StringUtility.getChar(aBufferdReader);
			if (aCharacter == null)
			{
				if (aBuffer.length() == 0) { return null; } else { break; }
			}
			if (aCharacter == '\n')
			{
				aBoolean = false;
			}
			else
			{
				if (aCharacter == ',')
				{
					aCollection.add(aBuffer.toString());
					aBuffer = new StringBuffer();
				}
				else
				{
					if (aCharacter == '"')
					{
						boolean aLoop = true;
						while (aLoop)
						{
							aCharacter = StringUtility.getChar(aBufferdReader);
							if (aCharacter == null)
							{
								if (aBuffer.length() == 0) { return null; } else { break; }
							}
							if (aCharacter == '"')
							{
								try
								{
									aBufferdReader.mark(256);
									aCharacter = StringUtility.getChar(aBufferdReader);
									if (aCharacter == null)
									{
										if (aBuffer.length() == 0) { return null; } else { break; }
									}
									if (aCharacter == '"')
									{
										aBuffer.append('"');
									}
									else
									{
										aBufferdReader.reset();
										aLoop = false;
									}
								}
								catch (IOException anException) { anException.printStackTrace(); }
							}
							else
							{
								aBuffer.append(aCharacter);
							}
						}
					}
					else
					{
						aBuffer.append(aCharacter);
					}
				}
			}
		}
		aCollection.add(aBuffer.toString());

		return aCollection;

	}

	/**
	 * 文字列の集まり(aCollection)をCSVの一行としてバッファードライター(aBufferedWriter)へ書き込むクラスメソッド。
	 * @param aBufferedWriter バッファードライター
	 * @param aCollection 文字列の集まり：CSVの一行
	 */
	public static void putRowCSV(BufferedWriter aBufferedWriter, List<String> aCollection)
	{
		try
		{
			for (int index = 0; index < aCollection.size(); index++)
			{
				if (index > 0) { aBufferedWriter.write(","); }
				String aString = aCollection.get(index);
				aBufferedWriter.write(StringUtility.csvString(aString));
			}
			aBufferedWriter.write('\n');
		}
		catch (IOException anException) { anException.printStackTrace(); }


		return;

	}

	/**
	 * 指定されたファイルからレコード(row)を読み込んで、それをレコードリストにして応答するクラスメソッド。
	 * @param aFile ファイル
	 * @return レコードリスト
	 */
	public static List<List<String>> readRowsFromFile(File aFile)
	{
		List<List<String>> aCollection = new ArrayList<List<String>>();
		try
		{
			FileInputStream inputStream = new FileInputStream(aFile);
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream, StringUtility.encodingSymbol());
			BufferedReader inputReader = new BufferedReader(inputStreamReader);

			List<String> aRow = null;
			while ((aRow = StringUtility.getRowCSV(inputReader)) != null)
			{
				aCollection.add(aRow);
			}

			inputReader.close();
		}
		catch (FileNotFoundException anException) { anException.printStackTrace(); }
		catch (UnsupportedEncodingException anException) { anException.printStackTrace(); }
		catch (IOException anException) { anException.printStackTrace(); }

		return aCollection;

	}

	/**
	 * 指定されたファイル文字列からレコード(row)を読み込んで、それをレコードリストにして応答するクラスメソッド。
	 * @param fileString ファイル名
	 * @return レコードリスト
	 */
	public static List<List<String>> readRowsFromFile(String fileString)
	{
		File aFile = new File(fileString);

		List<List<String>> aCollection = StringUtility.readRowsFromFile(aFile);

		return aCollection;

	}

	/**
	 * 指定されたファイルからテキストを読み込んで、それを行リストにして応答するクラスメソッド。
	 * @param aFile ファイル
	 * @return 行リスト
	 */
	public static List<String> readTextFromFile(File aFile)
	{
		List<String> aCollection = new ArrayList<String>();

		try
		{
			FileInputStream inputStream = new FileInputStream(aFile);
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream, StringUtility.encodingSymbol());
			BufferedReader inputReader = new BufferedReader(inputStreamReader);

			String aString = null;
			while ((aString = inputReader.readLine()) != null)
			{
				aCollection.add(aString);
			}

			inputReader.close();
		}
		catch (FileNotFoundException anException) { anException.printStackTrace(); }
		catch (UnsupportedEncodingException anException) { anException.printStackTrace(); }
		catch (IOException anException) { anException.printStackTrace(); }

		return aCollection;

	}

	/**
	 * 指定されたファイル文字列からテキストを読み込んで、それを行リストにして応答するクラスメソッド。
	 * @param fileString ファイル名
	 * @return 行リスト
	 */
	public static List<String> readTextFromFile(String fileString)
	{
		File aFile = new File(fileString);

		List<String> aCollection = StringUtility.readTextFromFile(aFile);

		return aCollection;

	}

	/**
	 * 指定されたURL文字列からテキストを読み込んで、それを行リストにして応答するクラスメソッド。
	 * @param urlString テキストのためのURL文字列
	 * @return 行リスト
	 */
	public static List<String> readTextFromURL(String urlString)
	{
		URL aURL = null;
		try { aURL = new URL(urlString); }
		catch (MalformedURLException anException) { anException.printStackTrace(); }

		List<String> aCollection = StringUtility.readTextFromURL(aURL);


		return aCollection;

	}

	/**
	 * 指定されたURLからテキストを読み込んで、それを行リストにして応答するクラスメソッド。
	 * @param aURL テキストのためのURL
	 * @return 行リスト
	 */
	public static List<String> readTextFromURL(URL aURL)
	{
		List<String> aCollection = new ArrayList<String>();

		try
		{
			InputStream inputStream = aURL.openStream();
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream, StringUtility.encodingSymbol());
			BufferedReader inputReader = new BufferedReader(inputStreamReader);

			String aString = null;
			while ((aString = inputReader.readLine()) != null)
			{
				aCollection.add(aString);
			}

			inputReader.close();
		}
		catch (UnsupportedEncodingException anException) { anException.printStackTrace(); }
		catch (IOException anException) { anException.printStackTrace(); }

		return aCollection;

	}

	/**
	 * 文字列をセパレータで分割したトークン列を応答するクラスメソッド。
	 * @param string 文字列
	 * @param separators 分割文字列
	 * @return セパレータで分割したトークン列
	 */
	public static List<String> splitString(String string, String separators)
	{
		List<Integer> indexes;
		int stop;
		int index;
		List<String> result;

		indexes = new ArrayList<Integer>();
		indexes.add(-1);
		stop = string.length();
		for (index = 0; index < stop; index++)
		{
			if ((separators.indexOf(string.charAt(index))) >= 0)
			{
				indexes.add(index);
			}
		}
		indexes.add(stop);
		stop = indexes.size() - 1;
		result = new ArrayList<String>();
		for (index = 0; index < stop; index++)
		{
			int start;
			int end;

			start = indexes.get(index) + 1;
			end = indexes.get(index + 1) - 1;
			if (end >= start)
			{
				result.add(string.substring(start, end + 1));
			}
		}
		
		return result;

	}

	/**
	 * 指定されたレコードリストを、指定されたファイルに書き出すクラスメソッド。
	 * @param aCollection レコードリスト
	 * @param aFile ファイル
	 */
	public static void writeRows(List<List<String>> aCollection, File aFile)
	{
		try
		{
			FileOutputStream outputStream = new FileOutputStream(aFile);
			OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream, StringUtility.encodingSymbol());
			BufferedWriter outputWriter = new BufferedWriter(outputStreamWriter);

			for (List<String> aRow : aCollection)
			{
				StringUtility.putRowCSV(outputWriter, aRow);
			}

			outputWriter.close();
		}
		catch (FileNotFoundException anException) { anException.printStackTrace(); }
		catch (UnsupportedEncodingException anException) { anException.printStackTrace(); }
		catch (IOException anException) { anException.printStackTrace(); }

		return;

	}

	/**
	 * 指定されたレコードリストを、指定されたファイル名のファイルに書き出すクラスメソッド。
	 * @param aCollection レコードリスト
	 * @param fileString ファイル名
	 */
	public static void writeRows(List<List<String>> aCollection, String fileString)
	{
		File aFile = new File(fileString);
		StringUtility.writeRows(aCollection, aFile);

		return;

	}

	/**
	 * 指定された行リストを、指定されたファイルに書き出すクラスメソッド。
	 * @param aCollection 行リスト
	 * @param aFile ファイル
	 */
	public static void writeText(List<String> aCollection, File aFile)
	{
		try
		{
			FileOutputStream outputStream = new FileOutputStream(aFile);
			OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream, StringUtility.encodingSymbol());
			BufferedWriter outputWriter = new BufferedWriter(outputStreamWriter);

			for (String aString : aCollection)
			{
				outputWriter.write(aString + "\n");
			}

			outputWriter.close();
		}
		catch (IOException anException) { anException.printStackTrace(); }

		return;

	}

	/**
	 * 指定された行リストを、指定されたファイル名のファイルに書き出すクラスメソッド。
	 * @param aCollection 行リスト
	 * @param fileString ファイル名
	 */
	public static void writeText(List<String> aCollection, String fileString)
	{
		File aFile = new File(fileString);
		StringUtility.writeText(aCollection, aFile);

		return;

	}
}

</pre>





<div class="belt">
<h3><a name="mvc.mf">mvc.mf</a>（マニフェストファイル）</h3>
</div>
<pre>Manifest-Version: 1.0
Main-Class: forest.Example</pre>
<div class="belt">
<h3><a name="Makefile">Makefile</a>（メイクファイル）</h3>
</div>
<pre>ANT	= env LC_ALL=ja_JP.UTF-8 ant

all:
	$(ANT) all

clean:
	$(ANT) clean

test:
	$(ANT) test

tree: clean
	$(ANT) tree

forest: clean
	$(ANT) forest

semilattice: clean
	$(ANT) semilattice

install:
	$(ANT) install

doc:
	$(ANT) doc

zip:
	$(ANT) zip</pre>
<div class="belt">
<h3><a name="build.xml">build.xml</a>（ビルドファイル）</h3>
</div>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;project name="Forest" default="all" basedir="."&gt;

	&lt;property name="package" value="forest" /&gt;
	&lt;property name="mvc" value="mvc" /&gt;
	&lt;property name="packagenames" value="${package},${mvc}" /&gt;
	&lt;property name="destdir" value="./Classes" /&gt;
	&lt;property name="docdir" value="./JavaDoc" /&gt;
	&lt;property name="instdir" value="./${ant.project.name}.app/Contents/Resources/Java" /&gt;
	&lt;property name="copyright" value="Copyright 2008-2017 AOKI Atsushi. All Rights Reserved." /&gt;
	&lt;property name="zipname" value="${ant.project.name}" /&gt;

	&lt;target name="all" depends="jar" description="build all"&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="prepare" depends="" description="prepare to compile"&gt;
		&lt;mkdir dir="${destdir}" /&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="compile" depends="prepare" description="compile all sources"&gt;
		&lt;javac
			fork="true"
			srcdir="${basedir}"
			destdir="${destdir}"
			includeAntRuntime="true"
			encoding="UTF-8"
			deprecation="on"
			verbose="false"&gt;
			&lt;compilerarg value="-J-Dfile.encoding=UTF8" /&gt;
			&lt;compilerarg value="-Xlint:all" /&gt;
			&lt;classpath&gt;
				&lt;pathelement location="." /&gt;
				&lt;pathelement location="${mvc}.jar" /&gt;
			&lt;/classpath&gt;
		&lt;/javac&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="jar" depends="compile" description="make jar file"&gt;
		&lt;jar
			jarfile="${package}.jar"
			basedir="${destdir}"
			manifest="${package}.mf"&gt;
			&lt;zipfileset src="${mvc}.jar" /&gt;
		&lt;/jar&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="clean" description="cleaning"&gt;
		&lt;delete dir="${destdir}" /&gt;
		&lt;delete file="${package}.jar" /&gt;
		&lt;delete dir="${docdir}" /&gt;
		&lt;delete dir="${instdir}" /&gt;
		&lt;delete file="../${zipname}.zip" /&gt;
		&lt;delete&gt;
			&lt;fileset dir="${package}" includes="*.class" /&gt;
		&lt;/delete&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="test" depends="all,tree" description="test"&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="tree" depends="all" description="tree"&gt;
		&lt;exec executable="java" spawn="false"&gt;
			&lt;arg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resource/data/tree.txt" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="forest" depends="all" description="forest"&gt;
		&lt;exec executable="java" spawn="false"&gt;
			&lt;arg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resource/data/forest.txt" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="semilattice" depends="all" description="semilattice"&gt;
		&lt;exec executable="java" spawn="false"&gt;
			&lt;arg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resource/data/semilattice.txt" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="install" depends="all" description="install into application"&gt;
		&lt;copy file="${package}.jar" todir="${instdir}" /&gt;
		&lt;copy file="resource/data/forest.txt" todir="${instdir}" /&gt;
		&lt;exec executable="chmod"&gt;
			&lt;arg line="755 ${instdir}/../../MacOS/applet" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="doc" depends="all" description="make document (javadoc)"&gt;
		&lt;mkdir dir="${docdir}" /&gt;
		&lt;javadoc
			locale="ja_JP"
			sourcepath="${basedir}"
			destdir="${docdir}"
			packagenames="${packagenames}"
			author="true"
			version="true"
			charset="UTF-8"
			encoding="UTF-8"
			docencoding="UTF-8"
			linksource="yes"
			additionalparam="-J-Dfile.encoding=UTF-8"
			access="private"&gt;
			&lt;doctitle&gt;${doc-title}&lt;/doctitle&gt;
			&lt;bottom&gt;${copyright}&lt;/bottom&gt;
			&lt;classpath&gt;
				&lt;pathelement location="." /&gt;
				&lt;pathelement location="${mvc}.jar" /&gt;
			&lt;/classpath&gt;
		&lt;/javadoc&gt;
		&lt;exec executable="open"&gt;
			&lt;arg line="-a /Applications/Safari.app ${docdir}/index.html" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="zip" depends="clean" description="make zip file"&gt;
		&lt;delete file="../${zipname}.zip" /&gt;
		&lt;zip destfile="../${zipname}.zip"&gt;
			&lt;zipfileset dir="." prefix="${zipname}" /&gt;
		&lt;/zip&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

&lt;/project&gt;</pre>

<hr>
<div class="right-small">Copyright 20xx Project xx, Updated: 2017/03/13 (Created: 2009/11/11)</div>
</body>
</html>